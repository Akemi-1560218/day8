'use strict'

//for of
//基礎
//1 関数 sumArray を宣言してください。
/**
 * @param {Array<number>} 数値型の要素を持つ配列
 * @returns {number} 与えられた配列のすべての数値の合計
 */
function sumArray() {
  // ここにコードを書きましょう。
}

actual = sumArray([1, 2, 3, 4]);
expected = 10;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//2 関数 productArray を宣言してください。
/**
 * @param {Array<number>} 数値型の要素を持つ配列
 * @returns {number} 与えられた配列の全ての数値をかけ合わせた積 (product)
 */
function productArray() {
  // ここにコードを書きましょう。
}

actual = productArray([1, 2, 3, 4]);
expected = 24;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//3 関数 hasFun を宣言してください。
/**
 * @param {Array<any>} 配列
 * @returns {boolean} 与えられた配列に "fun" という文字列が要素として入っているかどうかを表すブーリアン
 */
function hasFun() {
  // ここにコードを書きましょう。
}

actual = hasFun(["dog", 2, false, "fun", "hello"]);
expected = true;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = hasFun(["gift", 2, false, "run", "hello"]);
expected = false;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//4 関数 containsOnlyBooleans を宣言してください。
/**
 * @param {Array<any>} ???
 * @returns {boolean} 与えられた配列の要素がブーリアンだけかどうかを表すブーリアン
 */
function containsOnlyBooleans() {
  // ここにコードを書きましょう。
}

actual = containsOnlyBooleans([true, false, true, false, false]);
expected = true;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = containsOnlyBooleans([true, true, true, "not a boolean"]);
expected = false;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//5 関数 concatenate を宣言してください。JavaScript にビルトインされている concat メソッドは使わないで作ってみましょう。
/**
 * @param {Array<any>} 1番目の配列
 * @param {Array<any>} 2番目の配列
 * @returns {Array<any>} 与えられた2つの配列を連結させた配列
 */
function concatenate() {
  // ここにコードを書きましょう。
}

actual = concatenate(["one", "two"], ["three", "four"]);
expected = ["one", "two", "three", "four"];

// 配列同士を比較するため、ここでは JSON.stringify で文字列に変換することにしましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//6 関数 getEvenNumbers を宣言してください。
/**
 * @param {Array<number>} 数値型の要素を持つ配列

 * @returns {Array<number>} 与えられた配列の中の偶数だけを入れた配列
 */
function getEvenNumbers() {
  // ここにコードを書きましょう。
}

actual = getEvenNumbers([1, 2, 3, 4, 5, 6, 7, 8]);
expected = [2, 4, 6, 8];

// 上記と同じく、配列を比較するためここでは JSON.stringify を使いましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//7 関数 getMultipliedArray を宣言してください。
/**
 * @param {Array<number>} 第 1 引数：数値型の要素を持つ配列
 * @param {number} 第 2 引数：配列の中の数値にかける数値
 * @returns {Array<number>} 配列の中の数値に第 2 引数をかけた結果が入った新しい配列
 */
function getMultipliedArray() {
  // ここにコードを書きましょう。
}

actual = getMultipliedArray([1, 2, 3], 6);
expected = [6, 12, 18];

// 上記と同じく、配列を比較するためここでは JSON.stringify を使いましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//中級
//1 関数 isSorted を宣言してください。
/**
 * @param {Array<number>} 数値型の要素を持つ配列
 * @returns {boolean} 与えられた配列が昇順になっているかを表すブーリアン
 */
function isSorted() {
  // ここにコードを書きましょう。
}

actual = isSorted([1, 2, 3]);
expected = true;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = isSorted([3, 2, 3]);
expected = false;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//2 関数 countOccurrences を宣言してください。
/**
 * @param {Array<any>} 配列
 * @param {string|number|boolean} 配列内での出現回数をカウントしたい値（値のデータ型は `string`、`number`、`boolean` のいずれかとする）
 * @returns {number} 第 2 引数の値が第 1 引数の配列内で出てきた回数
 */
function countOccurrences() {
  // ここにコードを書きましょう。
}

actual = countOccurrences([1, 2, 3], 2);
expected = 1;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = countOccurrences([1, 2, 2], 2);
expected = 2;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = countOccurrences([1, 2, "cat"], "cat");
expected = 1;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//3 関数 myReverse を宣言してください。JavaScript のビルトインメソッド reverse は使わずに関数を作ってみましょう。
/**
 * @param {Array<any>} ???
 * @returns {Array<any>} 与えられた配列の要素が逆の順番に入っている新しい配列
 */
function myReverse() {
  // ここにコードを書きましょう。
}

const japaneseIslands = ["九州", "四国", "本州", "北海道"]; 　// 日本の島が入っている配列です。

actual = myReverse(japaneseIslands);
expected = ["北海道", "本州", "四国", "九州"];

// 上記と同じく、配列を比較するためここでは JSON.stringify を使いましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// 元の配列が変更されていないことを確認してください。

actual = japaneseIslands;
expected = ["九州", "四国", "本州", "北海道"];

if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//4 関数 getOperatedArray を宣言してください。
/**
 * @param {Array<number>} ???
 * @param {"+"|"-"|"*"|"/"|"**"|"%"} 使用したい算術演算子を表す文字列
 * @param {number} 使用したい被演算子
 * @returns {Array<any>} 与えられた配列の各要素に、引数の算術演算子と被演算子を適用した結果が入った新たな配列
 */
function getOperatedArray() {
  // ここにコードを書きましょう。
}

actual = getOperatedArray([1, 2, 3], "+", 5);
expected = [6, 7, 8];

// 上記と同じく、配列を比較するためここでは JSON.stringify を使いましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = getOperatedArray([9, 6, 3], "/", 3);
expected = [3, 2, 1];

//上記と同じく、配列を比較するためここでは JSON.stringify を使いましょう。
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//応用
//1 お医者さんを呼ぶ callADoctor（call a doctor）と言う名前の関数を作ります。この関数はお医者さんに身体のどこが痛いかを伝えます。
/**
 * @param {Array<string>} 「痛む場所」が入った配列
 * @returns {string} お医者さんに診てもらうときに言うセリフ
 */
function callADoctor() {
  // ここにコードを書きましょう。
}

actual = callADoctor(["頭"]);
expected = "先生、頭が痛いんです！";

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = callADoctor(["肩"]);
expected = "先生、肩が痛いんです！";

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = callADoctor(["頭", "肩", "膝", "足の指"]);
expected = "先生、頭と肩と膝と足の指が痛いんです！";

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//2 関数 deepCount を宣言してください。
/**
 * @param {Array<any>} ???
 * @returns {number} 与えられた配列の「要素」の数。このとき、入れ子になった配列がある場合は、その配列内の要素も一つ一つカウントすること。
 */
function deepCount() {
  // ここにコードを書きましょう。
}

actual = deepCount([1]);
expected = 1;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = deepCount([1, 3]);
expected = 2;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = deepCount([1, 3, [2, 4]]);
expected = 4;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

actual = deepCount(["a", "b", ["c", ["d", "e", ["f"]]]]);
expected = 6;

if (actual === expected) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//ナイトメア
//1 関数 mySort を宣言してください。 sort や toSorted() などのソートを行うメソッドは使わずに実装してみましょう🔥 
// アドバイス： 配列を並び替える方法はたくさんあります。自分の好きな方法を選んでください。これまでに同じような関数を書いたことがある人は違う方法にトライしましょう。
/**
 * @param {Array<number>} 数値型の要素を持つ配列
 * @returns {Array<number>} 与えられた配列の数値が昇順に並び替えられた配列
 */
function mySort() {
  // ここにコードを書きましょう。
}

let numbers = [5, 4, 3, 2, 1];

actual = mySort(numbers);
expected = [1, 2, 3, 4, 5];

// 正しい結果を返すことを確認する
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// 元の配列が変更されていないことを確認する
if (JSON.stringify(numbers) === JSON.stringify([5, 4, 3, 2, 1])) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

// さらにテストを書きましょう。

//2 関数 flattenDeep を宣言してください。
//配列の配列（何段階も深く入れ子になっている場合もある）を引数として受け取り、平坦化された、つまり、入れ子のない配列（＝ 1 次元配列）を新しく作って返します。
/**
 * @param {Array<any>} ???
 * @returns {Array<any>} 与えられた配列を 1 次元配列に平坦化した配列
 */
actual = flattenDeep([1, 2, 3, [4, 5, 6]]);
expected = [1, 2, 3, 4, 5, 6];

// 正しい結果を返すことを確認する
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

expected = [1, 2, 3, 4, 5, 6];
actual = flattenDeep([
  [1, 2, 3],
  [4, 5, 6],
]);

// 正しい結果を返すことを確認する
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

expected = [1, 2, 3, 4, 5, 6];
actual = flattenDeep([[1], [2], [3], [4, 5, 6]]);

// 正しい結果を返すことを確認する
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}

expected = [1, 2, 3, 4, 5, 6, 7, 8, 9];
actual = flattenDeep([[1, [2, [3, [4, [5, [6, [7, [8, [9]]]]]]]]]]);

// 正しい結果を返すことを確認する
if (JSON.stringify(actual) === JSON.stringify(expected)) {
  console.log("OK! Test PASSED.");
} else {
  console.error("Test FAILED. Try again!");
  console.group("Result:");
  console.log("  actual:", actual);
  console.log("expected:", expected);
  console.groupEnd();
}
